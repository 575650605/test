
如果一个由 '0' 和 '1' 组成的字符串，是以一些 '0'（可能没有 '0'）后面跟着一些 '1'（也可能没有 '1'）的形式组成的，那么该字符串是单调递增的。

我们给出一个由字符 '0' 和 '1' 组成的字符串 S，我们可以将任何 '0' 翻转为 '1' 或者将 '1' 翻转为 '0'。

返回使 S 单调递增的最小翻转次数。

提示：

1 <= S.length <= 20000
S 中只包含字符 '0' 和 '1'

示例 1：

输入："00110"
输出：1
解释：我们翻转最后一位得到 00111.
示例 2：

输入："010110"
输出：2
解释：我们翻转得到 011111，或者是 000111。
示例 3：

输入："00011000"
输出：2
解释：我们翻转得到 00000000。


int minFlipsMonoIncr(char * S){
    int last = 0;
    int i = 0;
    while(S[i] != '\0'){
        last++;
        i++;
    }
    int flip1 = 0;
    int times[20000] = {0};
    if(S[0] == '1'){
        flip1++;
    }
    // times[i]表示前i个字符所需最小翻转次数，则times[i+1]有如下四种情况，取其最小值即可
    // 1、第i+1个字符为0，且不翻转，times[i+1]=前i个字符中1的个数
    // 2、第i+1个字符为0，且翻转，times[i+1]=times[i]+1
    // 3、第i+1个字符为1，且不翻转，times[i+1]=times[i]
    // 4、第i+1个字符为1，且翻转，times[i+1]=前i个字符中1的个数+1
   for (i = 1; i < last; i++){
       if(S[i] == '0'){
           if((times[i - 1] + 1) > flip1){
               times[i] = flip1;
           } 
           else{
               times[i] = times[i - 1] + 1;
           }
       }
       else{
           flip1++;
           if(times[i - 1] > flip1){
                times[i] = flip1; 
           }
           else{
               times[i] = times[i - 1];
           }
       }
   }
   return times[i - 1];
}